import math
import time 
  
class Quaternion():
    """ 
        A basic quaternion object 
    """
    def __init__(self, w=1, x=0, y=0, z=0):
        a = [w,x,y,z]
        for i in a:
            if isinstance(i, int):
                i = float(i)
        self.w = w
        self.x = x
        self.y = y
        self.z = z
        self.normalise()
 
    def __str__(self):
        # Format for wolfram alpha checking
        return str(self.w)+'+'+str(self.x)+'i+'+str(self.y)+'j+'+str(self.z)+'k'
 
    def toEuler(self):
        """
        Retruns a EulerAngles object of itself (in degress)
        
        """                
        # yaw = atan2(2.0f*(qw*qz + qx*qy), 1-2.0*(qy*qy + qz*qz))
        # pitch = wrap_asin(2.0*(qw*qy - qz*qx))
        # roll = (atan2(2.0*(qw*qx + qy*qz), 1.0 - 2.0*(qx*qx + qy*qy)))
        yaw = math.atan2(2.0*(self.w*self.z + self.x*self.y),\
                        (1.0 - 2.0*(self.y**2 + self.z**2)))/math.pi*180.0

        roll = math.atan2(2.0*(self.w*self.x + self.y*self.z), \
                         1.0 - 2.0*(self.x**2 + self.y**2))/math.pi*180.0

        pitch = _wrap_asin(2.0*(self.w*self.y - self.z*self.x))/math.pi*180.0

        return EulerAngles(yaw, pitch, roll)
 
    def magnitude(self):
        """
        Returns the magnitude of this quaternion
        """
        return math.sqrt(self.w**2 + self.x**2 + self.y**2 + self.z**2)
 
    def normalise(self):
        """
        Normalise this quaternion
        """
        try:
            m = self.magnitude()
            self.w /= m
            self.x /= m
            self.y /= m
            self.z /= m
        except ZeroDivisionError:
            # Quaternion was init with no values
            pass
 
    def conjugate(self):
        """
        Returns a new quaternion that is the conjugate of this quaternion
        """
        return Quaternion(self.w, -self.x, -self.y, -self.z)
 
    def difference(self, q):
        """
        q = Quaternion
        Returns a new quaternion that is difference between this quaternion and q
        """
        # DeltaQ = Q(dest) * Q(origin)^{-1}
        return q.productOf(self.conjugate())
 
    def productOf(self, q):
        """
        q = Quaternion
        returns a quaternion thst is the product of this quaternion and q
        """               # (Q1 * Q2).w = (w1w2 - x1x2 - y1y2 - z1z2)
        return Quaternion(self.w*q.w - self.x*q.x - self.y*q.y - self.z*q.z,\
                          # (Q1 * Q2).x = (w1x2 + x1w2 + y1z2 - z1y2)
                          self.w*q.x + self.x*q.w + self.y*q.z - self.z*q.y,\
                          # (Q1 * Q2).y = (w1y2 - x1z2 + y1w2 + z1x2)
                          self.w*q.y - self.x*q.z + self.y*q.w + self.z*q.x,\
                          # (Q1 * Q2).z = (w1z2 + x1y2 - y1x2 + z1w2)
                          self.w*q.z + self.x*q.y - self.y*q.x + self.z*q.w)

    class EulerAngles():
        """
            A basic Euler object
        """
        def __init__(self, yaw = 0, pitch = 0, roll = 0):
            for i in [yaw, pitch, roll]:
                if isinstance(i, int):
                    i = float(i)
            self.yaw = yaw
            self.pitch = pitch
            self.roll = roll      
     
        def __str__(self):
            return 'Yaw(z): '+str(self.yaw)+' Pitch(y): '\
                    +str(self.pitch)+' Roll(x): '+str(self.roll)
     
        def getYaw(self):
            return self.yaw
     
        def getPitch(self):
            return self.pitch
     
        def getRoll(self):
            return self.roll
     
        def YPRvector(self):
            return (self.yaw, self.pitch, self.roll)
     
        def toQuaternion(self):
            """
            Returns a quaternion object of itself
            """  
            cosRoll  = math.cos(self.roll*math.pi/180.0*0.5)
            sinRoll  = math.sin(self.roll*math.pi/180.0*0.5)
            cosPitch = math.cos(self.pitch*math.pi/180.0*0.5)
            sinPitch = math.sin(self.pitch*math.pi/180.0*0.5)
            cosYaw   = math.cos(self.yaw*math.pi/180.0*0.5)
            sinYaw   = math.sin(self.yaw*math.pi/180.0*0.5)

            w = cosRoll*cosPitch*cosYaw + sinRoll*sinPitch*sinYaw
            x = sinRoll*cosPitch*cosYaw - cosRoll*sinPitch*sinYaw
            y = cosRoll*sinPitch*cosYaw + sinRoll*cosPitch*sinYaw
            z = cosRoll*cosPitch*sinYaw - sinRoll*sinPitch*cosYaw

            return Quaternion(w,x,y,z)

 
   
##################################################################################### 
 

class Kinematics(Quaternion):
    def __init__(self,  w=1, x=0, y=0, z=0):
        Quaternion.__init__(self, w, x, y, z)
        self.target = self
        self.time = time.time()
        self.degSecYPR = (0.0, 0.0, 0.0)
        self.error = self.difference(self.target)
 
    def __str__(self):
        data = 'Current Quaternion (W+Xi+Yj+Zk):\n'
        data += str(self.w)+'+'+str(self.x)+'i+'+str(self.y)+'j+'+str(self.z)+'k\n\n'
        data += 'Current attitude:\n'
        data += str(self.toEuler())+'\n\n'
        data += 'Target attitude:\n'
        data += str(self.target.toEuler())+'\n\n'
        data += 'Error:\n'
        data += str(self.error.toEuler())+'\n\n'
        data += 'Angular velocities (Deg/Sec):\n'
        data += str(self.getAngularVelocities())+'\n'
        return data

    def setTarget(self, q):
        """
        Set new target attitude quaternion
        """
        self.target = q
        self.update(self, q)

    def rotateTarget(self, q):
        """
        Set new target attitude quaternion
        """
        self.target = self.target.productOf(q)
        self.update(self, self.target)
 
    def getAngularVelocities(self):
        """
        Get angular velocity in deg/sec
        """
        return self.degSecYPR

    def getErrorQuaternion(self):
        """
        Get error (self vs target) as a quaternion
        """
        return self.error
 
    def getErrorEuler(self):
        """
        Get error (self vs target) as a Euler object
        """
        return self.error.toEuler()
 
    def update(self, attitude, target):
        """
        Update current attitude (attitude) and target attitude (target),
        calculate angular velocities and realtime error.
        """
        # delta T
        prevTime = self.time
        self.time = time.time()
        dt = self.time - prevTime
        # store attitude
        prev = Quaternion(self.w, self.x, self.y, self.z)
        # adopt new attitude
        self.w = attitude.w
        self.x = attitude.x
        self.y = attitude.y
        self.z = attitude.z
        # adopt new target rotation
        self.target = target
        # calculate attitude change as Euler angles
        delta = prev.difference(self).toEuler()
        # calculate angular velocities in deg/sec
        self.degSecYPR = (delta.getYaw()/dt, delta.getPitch()/dt, delta.getRoll()/dt)
        # calculate target error as a unit quaternion
        self.error = self.difference(self.target)
 
       
#####################################################################################
 
         
def _wrap_asin(v):
    """
    Constrain asin inputs
    """
    if v >= 1.0: return math.pi/2.0
    elif v <= -1.0: return -math.pi/2.0
    else: return math.asin(v)
    

#####################################################################################    
    
    #  Tests

#####################################################################################
    
if __name__=="__main__":
    
    def test1():
        # Euler to quaternion back to Euler
        for n in xrange(91):
            # Start in good ol' Euler angles
            e = EulerAngles(n*2,n-1,n/2.0)
            q = e.toQuaternion()
            print '#'*3+'TEST CASE = ',e,'#'*3
            print 'To Quaternion = ', q
            print 'Back to Euler = ', q.toEuler(), '\n'
     
    def test2():
        # Target error test
        k = Kinematics() 
        # Yaw 0, Pitch 0, Roll +90
        k.update(k, Quaternion(1,1,0,0))
        print k
      
    def test3():
        # Make a relative modification to the target attitude  
        # (relative change described as both Euler and Quaternion)
        body = Kinematics()
        print body
        print '#'*30,'\nAdding +89 degrees pitch...\n','#'*30
        # As a conversion from Euler angles
        change = EulerAngles(0,89,0).toQuaternion()
        body.rotateTarget(change)
        print body
        print '#'*30,'\nAdding +90 degrees roll...\n','#'*30
        # As a quaternion
        change = Quaternion(1,1,0,0)
        body.rotateTarget(change)
        print body
        
